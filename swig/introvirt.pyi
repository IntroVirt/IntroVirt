"""Python bindings for the IntroVirt VM introspection library."""

from typing import Any, Iterator, List, Optional, overload

# Event type constants
EventType_EVENT_FAST_SYSCALL: int
EventType_EVENT_FAST_SYSCALL_RET: int
EventType_EVENT_SW_INT: int
EventType_EVENT_SW_IRET: int
EventType_EVENT_CR_READ: int
EventType_EVENT_CR_WRITE: int
EventType_EVENT_MSR_READ: int
EventType_EVENT_MSR_WRITE: int
EventType_EVENT_EXCEPTION: int
EventType_EVENT_MEM_ACCESS: int
EventType_EVENT_SINGLE_STEP: int
EventType_EVENT_HYPERCALL: int
EventType_EVENT_REBOOT: int
EventType_EVENT_SHUTDOWN: int
EventType_EVENT_MAX: int
EventType_EVENT_UNKNOWN: int

# FastCallType constants
FastCallType_FASTCALL_SYSCALL: int
FastCallType_FASTCALL_SYSRET: int
FastCallType_FASTCALL_SYSENTER: int
FastCallType_FASTCALL_SYSEXIT: int
FastCallType_FASTCALL_UNKNOWN: int

# OS constants
OS_Unknown: int
OS_Windows: int
OS_Linux: int

# x86::Exception (for Vcpu.inject_exception)
Exception_GP_FAULT: int  # 13

# SystemCallIndex: many constants SystemCallIndex_<Name> (e.g. SystemCallIndex_NtCreateFile) are exported as int
SystemCallIndex_NtCreateFile: int
SystemCallIndex_NtOpenFile: int


class NTSTATUS:
    def __init__(self, value: int = 0) -> None: ...
    def value(self) -> int: ...
    def NT_SUCCESS(self) -> bool: ...
    def NT_INFORMATION(self) -> bool: ...
    def NT_WARNING(self) -> bool: ...
    def NT_ERROR(self) -> bool: ...
    def initialized(self) -> bool: ...


class DomainInformation:
    domain_name: str
    domain_id: int

    def __init__(self) -> None: ...


class DomainInformationVector:
    def __len__(self) -> int: ...
    def __getitem__(self, i: int) -> DomainInformation: ...
    def __iter__(self) -> Iterator[DomainInformation]: ...


class StringSet:
    def add(self, x: str) -> None: ...
    def __contains__(self, x: object) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...


class EventTaskInformation:
    def pid(self) -> int: ...
    def tid(self) -> int: ...
    def process_name(self) -> str: ...


class SystemCall:
    def name(self) -> str: ...
    def supported(self) -> bool: ...
    def will_return(self) -> bool: ...


class SystemCallEvent:
    def instruction(self) -> int: ...
    def handler(self) -> Optional[SystemCall]: ...
    def name(self) -> str: ...
    def raw_index(self) -> int: ...
    def hook_return(self, enabled: bool) -> None: ...
    def return_address(self) -> int: ...


class SystemCallFilter:
    @overload
    def mask(self, mask: int) -> None: ...
    @overload
    def mask(self) -> int: ...
    def enabled(self, enabled: Optional[bool] = None) -> bool: ...
    def set_32(self, index: int, enabled: bool) -> None: ...
    def set_64(self, index: int, enabled: bool) -> None: ...
    def clear(self) -> None: ...
    def matches(self, event: Event) -> bool: ...

    def __init__(self) -> None: ...


class Guest:
    def os(self) -> int: ...
    def x64(self) -> bool: ...


def set_register_rax(regs: Registers, val: int) -> None: ...


class Registers:
    def rax(self, val: Optional[int] = None) -> int: ...
    def rbx(self, val: Optional[int] = None) -> int: ...
    def rcx(self, val: Optional[int] = None) -> int: ...
    def rdx(self, val: Optional[int] = None) -> int: ...
    def rsp(self, val: Optional[int] = None) -> int: ...
    def rbp(self, val: Optional[int] = None) -> int: ...
    def rip(self, val: Optional[int] = None) -> int: ...
    def r8(self, val: Optional[int] = None) -> int: ...
    def r9(self, val: Optional[int] = None) -> int: ...
    def r10(self, val: Optional[int] = None) -> int: ...
    def r11(self, val: Optional[int] = None) -> int: ...
    def r12(self, val: Optional[int] = None) -> int: ...
    def r13(self, val: Optional[int] = None) -> int: ...
    def r14(self, val: Optional[int] = None) -> int: ...
    def r15(self, val: Optional[int] = None) -> int: ...
    def cr2(self) -> int: ...
    def cr3(self) -> int: ...
    def cr8(self) -> int: ...
    def gdtr_base(self) -> int: ...
    def gdtr_limit(self) -> int: ...
    def idtr_base(self) -> int: ...
    def idtr_limit(self) -> int: ...
    def cs_long_mode(self) -> bool: ...


class ControlRegisterEvent:
    def index(self) -> int: ...
    def value(self) -> int: ...


class Vcpu:
    def id(self) -> int: ...
    def registers(self) -> Registers: ...
    def intercept_cr_writes(self, cr: int, enabled: bool) -> None: ...
    def intercept_cr_writes(self, cr: int) -> bool: ...
    def inject_exception(self, vector: int, error_code: int = 0) -> None: ...


class Domain:
    def detect_guest(self) -> bool: ...
    def guest(self) -> Optional[Guest]: ...
    def name(self) -> str: ...
    def id(self) -> int: ...
    def vcpu_count(self) -> int: ...
    def vcpu(self, index: int) -> Vcpu: ...
    def poll(self, callback: "EventCallback") -> None: ...
    def interrupt(self) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def task_filter(self) -> "TaskFilter": ...
    def system_call_filter(self) -> SystemCallFilter: ...
    def intercept_system_calls(self, enabled: bool) -> None: ...
    def intercept_cr_writes(self, cr: int, enabled: bool) -> None: ...


class MemAccessEvent:
    def write_violation(self) -> bool: ...
    def read_violation(self) -> bool: ...
    def execute_violation(self) -> bool: ...
    def physical_address_value(self) -> int: ...


class Event:
    def vcpu(self) -> Vcpu: ...
    def domain(self) -> Domain: ...
    def type(self) -> int: ...
    def syscall(self) -> Optional[SystemCallEvent]: ...
    def task(self) -> EventTaskInformation: ...
    def cr(self) -> ControlRegisterEvent: ...
    def os_type(self) -> int: ...
    def id(self) -> int: ...
    def mem_access(self) -> MemAccessEvent: ...


class EventCallback:
    def process_event(self, event: Event) -> None: ...

    def __init__(self) -> None: ...


class TaskFilter:
    def add_pid(self, pid: int) -> None: ...
    def remove_pid(self, pid: int) -> None: ...
    def add_tid(self, tid: int) -> None: ...
    def remove_tid(self, tid: int) -> None: ...
    def add_name(self, name: str) -> None: ...
    def remove_name(self, name: str) -> None: ...
    def clear(self) -> None: ...
    def matches(self, event: Event) -> bool: ...

    def __init__(self) -> None: ...


class Hypervisor:
    @staticmethod
    def instance() -> "Hypervisor": ...

    @overload
    def attach_domain(self, domain_id: int) -> Domain: ...

    @overload
    def attach_domain(self, domain_name: str) -> Domain: ...

    def get_running_domains(self) -> DomainInformationVector: ...
    def hypervisor_name(self) -> str: ...
    def hypervisor_version(self) -> str: ...
    def hypervisor_patch_version(self) -> str: ...
    def library_name(self) -> str: ...
    def library_version(self) -> str: ...


class WindowsEvent(Event):
    def task(self) -> "WindowsEventTaskInformation": ...
    def syscall(self) -> "WindowsSystemCallEvent": ...
    def guest(self) -> "WindowsGuest": ...


class WindowsSystemCallEvent(SystemCallEvent):
    def handler(self) -> Optional["WindowsSystemCall"]: ...
    def index(self) -> int: ...


class WindowsSystemCall(SystemCall):
    def index(self) -> int: ...


class WindowsEventTaskInformation(EventTaskInformation):
    def pid(self) -> int: ...
    def tid(self) -> int: ...
    def process_name(self) -> str: ...
    def pcr(self) -> "KPCR": ...


class KPCR:
    def pid(self) -> int: ...
    def tid(self) -> int: ...
    def process_name(self) -> str: ...
    def KernelDirectoryTableBase(self) -> int: ...
    def idle(self) -> bool: ...
    def reset(self) -> None: ...


class OBJECT_ATTRIBUTES:
    def Length(self) -> int: ...
    def RootDirectory(self) -> int: ...
    def ObjectName(self) -> str: ...
    def isInheritable(self) -> bool: ...
    def FullPath(self, kpcr: KPCR) -> str: ...


class NtSystemCall(WindowsSystemCall):
    def result(self) -> NTSTATUS: ...


class NtCreateFile(NtSystemCall):
    def FileHandle(self) -> int: ...
    def ObjectAttributes(self) -> Optional[OBJECT_ATTRIBUTES]: ...


class NtOpenFile(NtSystemCall):
    def FileHandle(self) -> int: ...
    def ObjectAttributes(self) -> Optional[OBJECT_ATTRIBUTES]: ...


class NtClose(NtSystemCall):
    @overload
    def Handle(self) -> int: ...
    @overload
    def Handle(self, handle: int) -> None: ...


class NtReadFile(NtSystemCall):
    def FileHandle(self) -> int: ...


class NtWriteFile(NtSystemCall):
    def FileHandle(self) -> int: ...


class NtTerminateProcess(NtSystemCall):
    @overload
    def ProcessHandle(self) -> int: ...
    @overload
    def ProcessHandle(self, handle: int) -> None: ...
    def target_pid(self) -> int: ...


class NtOpenProcess(NtSystemCall):
    def ProcessHandle(self) -> int: ...


class NtDuplicateObject(NtSystemCall):
    def SourceHandle(self) -> int: ...
    def TargetHandle(self) -> int: ...
    def ObjectAttributes(self) -> Optional[OBJECT_ATTRIBUTES]: ...


class NtQueryAttributesFile(NtSystemCall):
    def ObjectAttributes(self) -> Optional[OBJECT_ATTRIBUTES]: ...


class NtQueryFullAttributesFile(NtSystemCall):
    def ObjectAttributes(self) -> Optional[OBJECT_ATTRIBUTES]: ...


class NtDeleteFile(NtSystemCall):
    def ObjectAttributes(self) -> Optional[OBJECT_ATTRIBUTES]: ...


class NtQueryInformationFile(NtSystemCall):
    def FileHandle(self) -> int: ...


class NtSetInformationFile(NtSystemCall):
    def FileHandle(self) -> int: ...


class NtDeviceIoControlFile(NtSystemCall):
    def FileHandle(self) -> int: ...


class NtMapViewOfSection(NtSystemCall): ...


class WindowsGuest(Guest):
    def default_syscall_filter(self, filter: SystemCallFilter) -> None: ...
    def set_system_call_filter(self, filter: SystemCallFilter, index: int, value: bool) -> bool: ...
    @staticmethod
    def syscall_categories() -> List[str]: ...
    def enable_category(self, category: str, filter: SystemCallFilter) -> None: ...


def WindowsGuest_from_guest(g: Guest) -> Optional[WindowsGuest]: ...
def get_nt_open_process_target_pid(handler: NtOpenProcess) -> int: ...
def block_open_process_client_id(handler: NtOpenProcess) -> None: ...


def to_string(*args: Any) -> str: ...


def nt_success(code: int) -> bool: ...
def nt_error(code: int) -> bool: ...
def nt_warning(code: int) -> bool: ...
def nt_information(code: int) -> bool: ...
def ntstatus_to_string(code: int) -> str: ...
def get_windows_syscall_result_value(event: Event) -> tuple[bool, int]: ...
def get_concrete_handler(wevent: "WindowsEvent") -> Optional["WindowsSystemCall"]: ...
def system_call_from_string(name: str) -> int: ...


def get_executable_mapped_modules(event: Optional["Event"]) -> list[tuple[int, str]]: ...
def resolve_symbols_via_pdb(
    domain: Domain, vcpu: Vcpu, base_address: int, patterns: list[str]
) -> list[tuple[int, str]]: ...
def resolve_symbol_by_name(
    domain: Domain, vcpu: Vcpu, base_address: int, symbol_name: str
) -> Optional[tuple[int, str]]: ...
def pdb_rva_to_guest_address(base_address: int, rva: int) -> int: ...


class Breakpoint: ...


class BreakpointCallback:
    def breakpoint_hit(self, event: Event) -> None: ...


def read_guest_uint64(domain: Domain, vcpu: Vcpu, vaddr: int) -> int: ...
def read_guest_uint32(domain: Domain, vcpu: Vcpu, vaddr: int) -> int: ...
def read_guest_cstring(domain: Domain, vcpu: Vcpu, vaddr: int) -> str: ...
def read_guest_bytes(domain: Domain, vcpu: Vcpu, vaddr: int, size: int) -> bytes: ...
def write_guest_bytes(domain: Domain, vcpu: Vcpu, vaddr: int, data: bytes) -> None: ...


def create_breakpoint(
    domain: Domain, vcpu: Vcpu, address: int, callback: BreakpointCallback
) -> Optional[Breakpoint]: ...


class BreakpointHolder:
    """Holds a breakpoint; when destroyed, frees the underlying shared_ptr (use to avoid exit leak)."""
    def get(self) -> Breakpoint: ...


def create_breakpoint_holder(
    domain: Domain, vcpu: Vcpu, address: int, callback: BreakpointCallback
) -> Optional[BreakpointHolder]: ...


class Watchpoint: ...


class WatchpointCallback:
    def watchpoint_hit(self, event: Event) -> None: ...


def create_watchpoint(
    domain: Domain,
    vcpu: Vcpu,
    address: int,
    length: int,
    read: bool,
    write: bool,
    execute: bool,
    callback: WatchpointCallback,
) -> Optional[Watchpoint]: ...


class SingleStep:
    def vcpu(self) -> Vcpu: ...


class SingleStepCallback:
    def single_step_hit(self, event: Event) -> None: ...


def single_step(
    domain: Domain, vcpu: Vcpu, callback: SingleStepCallback
) -> Optional[SingleStep]: ...


# Exception types
class IntroVirtError(Exception): ...


class NoSuchDomainException(IntroVirtError): ...


class DomainBusyException(IntroVirtError): ...


class UnsupportedHypervisorException(IntroVirtError): ...


class GuestDetectionException(IntroVirtError): ...


class InvalidMethodException(IntroVirtError): ...


class InvalidVcpuException(IntroVirtError): ...


class NotImplementedException(IntroVirtError): ...


class CommandFailedException(IntroVirtError): ...


class BadPhysicalAddressException(IntroVirtError): ...


class VirtualAddressNotPresentException(IntroVirtError): ...


class PeException(IntroVirtError): ...


# PE (Portable Executable) helpers
class PE: ...


def pe_from_address(domain: Domain, vcpu: Vcpu, base_address: int) -> Optional[PE]: ...
def pe_base_address(pe: Optional[PE]) -> int: ...
def pe_section_virtual_address(section: Any) -> int: ...
def pe_export_address_value(exp: Any) -> int: ...
def pe_export_by_name(pe: Optional[PE], name: str) -> Optional[tuple[int, str]]: ...
def pe_export_names(pe: Optional[PE]) -> List[str]: ...
